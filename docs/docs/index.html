<!DOCTYPE html><html lang="en"><head>
    <title>Proxima | default title</title>
    <meta name="description" content="default description">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../assets/docs.ea884d03.css"><link rel="stylesheet" type="text/css" href="../assets/default.0663dc4e.css">
    
    
    
<script type="module" src="../assets/docs.9e9b1e1f.js"></script></head><body class="default" onload="document.body.style.opacity='1'">
  
  
    
    
    <header class="fixed w-full z-50">
      
        <div class="min-h-16 h-16 bg-astro">
          <astro-root uid="1DOYQu"></astro-root>
        </div>
      
    </header>
  
    <main class="pt-20">
      <div class="bg-centauri astro-65RN2VJD">
		<div class="p-6 astro-65RN2VJD">
			<h1 class="text-center text-4xl uppercase font-bold astro-65RN2VJD">Documentation</h1>
			

<p style="" class="mt-6 text-3xl astro-65RN2VJD">
				Below you will find all attributes you can use to control the animations.
			</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let d=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;false&quot;,g=&quot;transform: [scale(0), rotate(359deg), scale(0.5), rotate(42deg), scale(1)]&quot;,v={duration:900,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;transform&quot;,l=&quot;visibleonce&quot;,O=&quot;30&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,b=[],C=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,b[r]=this.shadowCalc(t,c),C[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=b[r]+L/3.65,this.currentLineLen+b[r+1]>B&amp;&amp;(C.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,c=!1,C[T+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}T++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;d(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;d(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;d(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		</div>
	</div><div class="p-6 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			X-Element
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:2500},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				fx is built on top of X-Element using &lt;X&gt;Your Content&lt;/X&gt; you can add animated web components.
			</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:2700},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			type
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:2500},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Represents the type of tag you want to render, p, span, a, div, h1-h6, img etc...
				use with type="h2"
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: span </strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:2700},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			easing
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Add an easing function to your animation, linear, ease-in-out, cubic-bezier and more.
				<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/easing-function" target="_blank" title="mdn easing functions" class="astro-65RN2VJD">Learn more.</a><strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: linear </strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			duration
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The duration of the animation in milliseconds (ms) 
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: 1500</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			fill
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Control the animation fill mode to control css properties before and after the animation.
				<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation-fill-mode" target="_blank" title="mdn fill mode" class="astro-65RN2VJD">Learn more.</a><strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: both</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			gradient
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Apply a linear gradient to the node. For example:
			</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>


<p style="
		background: linear-gradient(to right, red, green, yellow);
		-webkit-background-clip: text;
		-webkit-text-fill-color: transparent;
	" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">"to right, red, green, yellow"
				</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>


<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				params will be passed to the linear-gradient function
				<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient()" target="_blank" title="mdn linear gradient" class="astro-65RN2VJD">Learn more.</a><strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: ''</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			direction
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The direction of the animation. Used to play backwards (flip the animation cycle)
				<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation-direction" target="_blank" title="mdn animation direction" class="astro-65RN2VJD">Learn more.</a><strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: normal</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			iterations
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The number of times an animation should run. Use 0 to run infinite.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: 1</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			delay
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The delay before an animation starts playing.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: 0</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			fullNode
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Wether to animate the entire node or it's single parts (letters). Does only work on nodes with text content.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: "true"</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			delayBetween
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The delay between each letter. Only works if fullNode is set to false.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: 0</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			clean
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				Decide if spans should continue to exist after the animation completes. Only works if
				fullNode is set to false.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: true</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			retain
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				You can retain specific properties, for example retain="color, transform" would retain both css properties last value
				of the animation independent of fill. If not set the node will fall back to it's initial styles.
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: "false"</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			trigger
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The trigger for the animation to run. Possible values: visible, visibleonce, click, mouseenter, mouseleave
				<strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: visible</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-65RN2VJD">
		

<h3 style="" class="underline astro-65RN2VJD">
			animations
		</h3><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:d,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;false&quot;,d=&quot;transform: [scaleX(0), scaleX(2), scaleX(1)] | color: [red, randomColor, yellow, randomColor, orange]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visible&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,L=[],b=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,L[r]=this.shadowCalc(t,c),b[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(b.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,c=!1,b[w+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}w++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;d!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		

<div style="" class="mt-3 text-yellow-500 astro-65RN2VJD">

<p style="" class="mt-3 text-yellow-500 text-2xl astro-65RN2VJD">
				The animations to run on the node or it's parts. <strong class="block mt-3 astro-65RN2VJD">Example:</strong><span class="text-indigo-400 astro-65RN2VJD">color: [#aa0033, #00aa33, red, orange, rgba(117, 117, 117, 0.9), randomColor, randomColor]</span><span class="text-red-600 astro-65RN2VJD"> | </span><span class="text-indigo-400 astro-65RN2VJD">transform: [translateX(-50%), scale(2), rotate(45deg)]</span><span class="text-red-600 astro-65RN2VJD"> | </span><span class="text-indigo-400 astro-65RN2VJD">padding: [3px, 6px, 9px]</span><strong class="text-pink-500 block mt-3 astro-65RN2VJD">hint: randomColor applies a random color</strong><strong class="block mt-3 text-green-500 astro-65RN2VJD">Default: ''</strong></p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;&quot;,v={duration:1500,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>
</div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateX(-70%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div>
    </main>
  
    <footer class="lg:container lg:mx-auto">
      
        <div class="flex p-3">
          <div class="flex-grow text-left">
            <a href="https://github.com/p13rnd/proxima/blob/master/LICENSE.md" target="_blank" title="show license">MIT</a>
          </div>
          <div class="flex-grow text-center">
            <a href="https://github.com/p13rnd/proxima" target="_blank" title="view on github">
              
<svg viewBox="0 0 32 32" class="mx-auto text-6xl" width="1em" height="1em" astro-icon="github"><path d="M16 .395c-8.836 0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182.8.148 1.094-.347 1.094-.77 0-.381-.015-1.642-.022-2.979-4.452.968-5.391-1.888-5.391-1.888-.728-1.849-1.776-2.341-1.776-2.341-1.452-.993.11-.973.11-.973 1.606.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33.143-1.034.558-1.74 1.016-2.14-3.554-.404-7.29-1.777-7.29-7.907 0-1.747.625-3.174 1.649-4.295-.166-.403-.714-2.03.155-4.234 0 0 1.344-.43 4.401 1.64a15.353 15.353 0 0 1 4.005-.539c1.359.006 2.729.184 4.008.539 3.054-2.07 4.395-1.64 4.395-1.64.871 2.204.323 3.831.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295 0 6.145-3.743 7.498-7.306 7.895.574.497 1.085 1.47 1.085 2.963 0 2.141-.019 3.864-.019 4.391 0 .426.288.925 1.099.768C27.421 29.457 32 23.462 32 16.395c0-8.837-7.164-16-16-16z"></path></svg>

            </a>
          </div>
          <div class="flex-grow text-right">
            @2021
          </div>
        </div>
      
    </footer>
  
    
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const disposable = document.querySelectorAll('[disposable]');
    Array.from(disposable).map(item => {item.remove()});
  });
</script>

<svg style="width:0;height:0;position:absolute;" aria-hidden="true" focusable="false">
  <linearGradient id="logoGradient" x2="1" y2="1">
    <stop offset="0%" stop-color="#cfb41a"></stop>
    <stop offset="50%" stop-color="#d86c14"></stop>
    <stop offset="100%" stop-color="#d81414"></stop>
  </linearGradient>
</svg>

</body></html>