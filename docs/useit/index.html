<!DOCTYPE html><html lang="en"><head>
    <title>Proxima | default title</title>
    <meta name="description" content="default description">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="../assets/default.0663dc4e.css"><link rel="stylesheet" type="text/css" href="../assets/useit.43a04d33.css">
    
    
    
<script type="module" src="../assets/useit.049bf39f.js"></script></head><body class="default" onload="document.body.style.opacity='1'">
  
  
    
    
    <header class="fixed w-full z-50">
      
        <div class="min-h-16 h-16 bg-astro">
          <astro-root uid="1DOYQu"></astro-root>
        </div>
      
    </header>
  
    <main class="pt-20">
      <div class="bg-centauri astro-AFXGTOCG">
		<div class="p-6 astro-AFXGTOCG">
			<h1 class="text-center text-4xl uppercase font-bold astro-AFXGTOCG">GET STARTED</h1>
			

<p style="" class="mt-6 text-3xl astro-AFXGTOCG">
				Getting started is easy. Just install the library and you're ready to use it on your <a href="https://astro.build" target="_blank" title="with astro" class="astro-AFXGTOCG">astro</a> pages.
			</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(m,f){f=this,m=(await import(m.src)).default;let d=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;false&quot;,g=&quot;transform: [scale(0), rotate(359deg), scale(0.5), rotate(42deg), scale(1)]&quot;,v={duration:600,easing:&quot;cubic-bezier(0.375, 0.8, 0.5, 0.375)&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:1,delay:0},N=&quot;true&quot;,x=&quot;transform&quot;,l=&quot;visibleonce&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,b=[],C=[];s.map((n,r)=>{const c=document.createElement(&quot;span&quot;);c.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(c.innerText=a[i].innerText,i++):c.innerText=n,b[r]=this.shadowCalc(t,c),C[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=b[r]+L/3.65,this.currentLineLen+b[r+1]>B&amp;&amp;(C.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let c=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((S,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=S,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,c=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,c=!1,C[T+y+1]===&quot;<br>&quot;){const S=document.createElement(&quot;br&quot;);t.append(S),y++,o=!1}T++}o&amp;&amp;t.append(h),c===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],m)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],m)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;d(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;d(e.target,u)})(t,m)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;d(e.target,u)})(t,m)})}).call(this.previousSibling,this.remove()||this);
"></script>

		</div>
	</div><div class="p-6 astro-AFXGTOCG">
		

<h2 style="" class="mt-6 text-center uppercase font-bold astro-AFXGTOCG">
			animate everything with ease
		</h2><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,d){d=this,c=(await import(c.src)).default;let f=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;false&quot;,g=&quot;transform: [rotate(360deg), rotate(720deg), rotate(1080deg), rotate(1440deg), rotate(1800deg)] | color: [randomColor, randomColor, randomColor, randomColor, randomColor, randomColor, orange]&quot;,v={duration:1e3,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:5,delay:0},N=&quot;true&quot;,x=&quot;color&quot;,l=&quot;visibleonce&quot;,O=&quot;0&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const C=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,L=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,L[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+C/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${C/3.65}px`,m=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${C/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,o=!1}T++}o&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;f(i.target,u)})(t[0],c)).observe(d),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;f(i.target,u)})(t[0],c)).observe(d),d.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;f(e.target,u)})(t,c)}),d.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;f(e.target,u)})(t,c)}),d.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;f(e.target,u)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-AFXGTOCG">
		

<p style="" class="mt-6 text-xl text-center uppercase font-bold astro-AFXGTOCG">
			everything that is a css property and supported by web animation api can be animated.
		</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,d){d=this,c=(await import(c.src)).default;let g=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:f,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;false&quot;,f=&quot;color: [randomColor, randomColor, randomColor, randomColor, randomColor, randomColor, randomColor]&quot;,v={duration:6e3,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:0,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,l=&quot;visibleonce&quot;,O=&quot;50&quot;,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const A=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,L=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,L[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=L[r]+A/3.65,this.currentLineLen+L[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const C=document.createElement(&quot;span&quot;);C.innerText=b,C.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(C.style.width=`${A/3.65}px`,m=!1),o.append(C),e=C.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${A/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,o=!1}T++}o&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;f!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],c)).observe(d),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;f!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;g(i.target,u)})(t[0],c)).observe(d),d.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;f!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;g(e.target,u)})(t,c)}),d.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;f!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;g(e.target,u)})(t,c)}),d.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;f!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;g(e.target,u)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 text-center astro-AFXGTOCG">
		<h3 class="text-yellow-600 underline astro-AFXGTOCG">Create a simple loading 
		

<span style="" class="uppercase font-bold relative -mr-2 astro-AFXGTOCG">s
		</span><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let d=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;false&quot;,g=&quot;transform: [rotate(360deg)]&quot;,v={duration:9e3,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:0,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,l=&quot;visibleonce&quot;,O=0,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,o=!1}T++}o&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;d(e.target,u)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;d(e.target,u)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;d(e.target,u)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

		pinner</h3>
	</div><div class="p-6 w-40 mx-auto astro-AFXGTOCG">
		

<div style="" class="loader astro-AFXGTOCG"></div><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;transform: [rotate(360deg)]&quot;,v={duration:6e3,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;normal&quot;,iterations:0,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,l=&quot;visibleonce&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,o=!1}T++}o&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-AFXGTOCG">
		

<p style="" class=" text-center astro-AFXGTOCG">
			You can use a selection of triggers and any web animation api property.
		</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;opacity: [0] | transform: [translateY(50%)]&quot;,v={duration:900,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:1,delay:300},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visible&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 pt-0 astro-AFXGTOCG">
		

<p style="text-shadow: 1px 1px 1px #919191, 1px 2px 1px #919191, 1px 3px 1px #919191, 1px 4px 1px #919191, 1px 5px 1px #919191, 1px 6px 1px #919191, 1px 7px 1px #919191, 1px 8px 1px #919191, 1px 9px 1px #919191, 1px 10px 1px #919191, 1px 18px 6px rgba(16,16,16,0.4), 1px 22px 10px rgba(16,16,16,0.2), 1px 25px 35px rgba(16,16,16,0.2), 1px 30px 60px rgba(16,16,16,0.4);" class="text-9xl font-bold text-center astro-AFXGTOCG">
			3D
		</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let d=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(T),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},T=&quot;true&quot;,g=&quot;transform: [rotateY(359deg)] | color: [orange, yellow, red, orange]&quot;,v={duration:9e3,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:0,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,l=&quot;visibleonce&quot;,O=0,u={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let w=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let o=document.createElement(&quot;a&quot;);o.href=a[i].href,o.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),o.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(o),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=o=>{this.lastElementCb(o.target,r,p.length)});else{let o=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[w+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,o=!1}w++}o&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)<0&amp;&amp;l.search(&quot;visible&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;visibleonce&quot;)>-1&amp;&amp;d(i.target,u)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;click&quot;)>-1&amp;&amp;d(e.target,u)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseenter&quot;)>-1&amp;&amp;l.search(&quot;mouseleave&quot;)<0&amp;&amp;d(e.target,u)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;l.search(&quot;mouseleave&quot;)>-1&amp;&amp;l.search(&quot;mouseenter&quot;)<0&amp;&amp;d(e.target,u)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div><div class="p-6 astro-AFXGTOCG">
		<p class="mt-6 mb-12 text-center astro-AFXGTOCG">Star on Github</p>
		

<p style="" class="my-6 astro-AFXGTOCG">
<svg viewBox="0 0 32 32" class="mx-auto text-6xl astro-AFXGTOCG" width="1em" height="1em" astro-icon="arrow-down"><path d="m16 31 15-15h-9V0H10v16H1z"></path></svg>
</p><script type="module" src="data:text/javascript,export default {}" onload="(async function(c,f){f=this,c=(await import(c.src)).default;let u=(t,e)=>{t.isAnimating=!0,e.animateNode(t,{animationString:g,timing:v,split:!JSON.parse(w),clean:JSON.parse(N),retain:x,delayBetweenLetters:parseInt(O)})},w=&quot;true&quot;,g=&quot;transform: [translateY(10%), translateY(-10%)]&quot;,v={duration:600,easing:&quot;linear&quot;,fill:&quot;both&quot;,direction:&quot;alternate-reverse&quot;,iterations:0,delay:0},N=&quot;true&quot;,x=&quot;false&quot;,o=&quot;visibleonce&quot;,O=0,d={animations:&quot;color: [randomColor, randomColor]&quot;,node:void 0,timing:{duration:1500,easing:&quot;linear&quot;,fill:&quot;none&quot;,direction:&quot;normal&quot;,iterations:1},delay:0,delayBetweenLetters:0,clean:!0,retain:!1,currentLineLen:0,randomColor:()=>&quot;#xxxxxx&quot;.replace(/x/g,t=>(Math.random()*16|0).toString(16)),getAnimations:function(t){return t.split(&quot;|&quot;).map(e=>e.split(&quot;:&quot;).map(i=>i.trim())).reduce((e,i)=>(e[i[0]]=i[1].replace(&quot;[&quot;,&quot;&quot;).replace(&quot;]&quot;,&quot;&quot;).split(&quot;, &quot;).map(a=>a.replace(&quot;randomColor&quot;,this.randomColor())),e),{})},cleanUp:function(t){if(this.retain!==&quot;false&quot;){let i={};this.retain.split(&quot;, &quot;).forEach(a=>{const s=a.split(/\[(.*?)\]/);if(this.animations[s[0]]!==void 0){const p=this.animations[s[0]][this.animations[s[0]].length-1];i[s[0]]=p}}),Object.assign(t.style,i)}let e=&quot;&quot;;Array.from(t.childNodes).forEach(i=>{i.tagName===&quot;A&quot;?(i.querySelectorAll(&quot;span&quot;).forEach(s=>{i.append(s.innerText),s.remove()}),e+=i.outerHTML):i.nodeName!==&quot;#text&quot;?(e+=i.innerText.length===0?&quot; &quot;:i.innerText,i.remove()):e=i.textContent}),t.innerHTML=e.trim()},animateNode:function(t,e){e.timing?.iterations<1&amp;&amp;(e.timing.iterations=1/0),this.node=t,this.delayBetweenLetters=e.delayBetweenLetters||this.delayBetweenLetters,this.timing=e.timing||this.timing,this.delay=e.timing.delay||this.delay,this.clean=e.clean||this.clean,this.retain=e.retain||this.retain,this.animations=this.getAnimations(e.animationString),e.split===!0?this.runSplitAnimations(t):this.runFullAnimations(t)},lastElementCb:function(t,e,i){e===i-1&amp;&amp;(this.cleanUp(t),t.isAnimating=!1)},runFullAnimations:function(t){const e=t.animate(this.animations,this.timing);e.onfinish=i=>{t.isAnimating=!1}},runSplitAnimations:function(t){let e,i=0;const a=t.querySelectorAll(&quot;a&quot;);a!==null&amp;&amp;a.length>0&amp;&amp;Array.from(a).forEach(n=>{t.textContent=t.textContent.replace(n.innerText,&quot;*&quot;)}),t.textContent=t.textContent.trim();const s=t.textContent.split(&quot; &quot;),p=t.textContent.split(&quot;&quot;);t.textContent=&quot;&quot;;const L=parseFloat(window.getComputedStyle(t,null).getPropertyValue(&quot;font-size&quot;))||24,B=t.clientWidth;let T=0,C=[],S=[];s.map((n,r)=>{const m=document.createElement(&quot;span&quot;);m.style.display=&quot;inline-block&quot;,n===&quot;*&quot;?(m.innerText=a[i].innerText,i++):m.innerText=n,C[r]=this.shadowCalc(t,m),S[r]=n});let y=0;s.map((n,r)=>{this.currentLineLen+=C[r]+L/3.65,this.currentLineLen+C[r+1]>B&amp;&amp;(S.splice(r+y+1,0,&quot;<br>&quot;),this.currentLineLen=0,y++)}),y=0,i=0,p.forEach((n,r)=>{let m=!0;if(n===&quot;*&quot;){let l=document.createElement(&quot;a&quot;);l.href=a[i].href,l.target=a[i].target,a[i].innerText.split(&quot;&quot;).forEach((b,E)=>{const A=document.createElement(&quot;span&quot;);A.innerText=b,A.style.display=&quot;inline-block&quot;,n===&quot; &quot;&amp;&amp;(A.style.width=`${L/3.65}px`,m=!1),l.append(A),e=A.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+E+1)})}),t.append(l),i++;return}if(n instanceof HTMLElement)e=n.animate(this.animations,this.timing),this.clean===!0&amp;&amp;(e.onfinish=l=>{this.lastElementCb(l.target,r,p.length)});else{let l=!0;const h=document.createElement(&quot;span&quot;);if(h.style.display=&quot;inline-block&quot;,h.innerText=n,n===&quot; &quot;){if(h.innerText=&quot;&quot;,h.style.width=`${L/3.65}px`,m=!1,S[T+y+1]===&quot;<br>&quot;){const b=document.createElement(&quot;br&quot;);t.append(b),y++,l=!1}T++}l&amp;&amp;t.append(h),m===!0&amp;&amp;(e=h.animate(this.animations,{duration:this.timing.duration,easing:this.timing.easing,fill:this.timing.fill,direction:this.timing.direction,iterations:this.timing.iterations,delay:this.timing.delay+this.delayBetweenLetters*(r+1)}),this.clean===!0&amp;&amp;(e.onfinish=()=>{this.lastElementCb(t,r,p.length)}))}})},shadowCalc:(t,e)=>{e.style.visibility=&quot;hidden&quot;,t.append(e);const i=e.clientWidth;return t.removeChild(e),i}};new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)<0&amp;&amp;o.search(&quot;visible&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),new IntersectionObserver((t,e)=>t[0].isIntersecting&amp;&amp;!e.disconnect()&amp;&amp;(i=>{i.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;visibleonce&quot;)>-1&amp;&amp;u(i.target,d)})(t[0],c)).observe(f),f.addEventListener(&quot;click&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;click&quot;)>-1&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseenter&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseenter&quot;)>-1&amp;&amp;o.search(&quot;mouseleave&quot;)<0&amp;&amp;u(e.target,d)})(t,c)}),f.addEventListener(&quot;mouseleave&quot;,t=>{(e=>{e.target.isAnimating!=!0&amp;&amp;g!==&quot;&quot;&amp;&amp;o.search(&quot;mouseleave&quot;)>-1&amp;&amp;o.search(&quot;mouseenter&quot;)<0&amp;&amp;u(e.target,d)})(t,c)})}).call(this.previousSibling,this.remove()||this);
"></script>

	</div>
    </main>
  
    <footer class="lg:container lg:mx-auto">
      
        <div class="flex p-3">
          <div class="flex-grow text-left">
            <a href="https://github.com/p13rnd/proxima/blob/master/LICENSE.md" target="_blank" title="show license">MIT</a>
          </div>
          <div class="flex-grow text-center">
            <a href="https://github.com/p13rnd/proxima" target="_blank" title="view on github">
              
<svg viewBox="0 0 32 32" class="mx-auto text-6xl" width="1em" height="1em" astro-icon="github"><path d="M16 .395c-8.836 0-16 7.163-16 16 0 7.069 4.585 13.067 10.942 15.182.8.148 1.094-.347 1.094-.77 0-.381-.015-1.642-.022-2.979-4.452.968-5.391-1.888-5.391-1.888-.728-1.849-1.776-2.341-1.776-2.341-1.452-.993.11-.973.11-.973 1.606.113 2.452 1.649 2.452 1.649 1.427 2.446 3.743 1.739 4.656 1.33.143-1.034.558-1.74 1.016-2.14-3.554-.404-7.29-1.777-7.29-7.907 0-1.747.625-3.174 1.649-4.295-.166-.403-.714-2.03.155-4.234 0 0 1.344-.43 4.401 1.64a15.353 15.353 0 0 1 4.005-.539c1.359.006 2.729.184 4.008.539 3.054-2.07 4.395-1.64 4.395-1.64.871 2.204.323 3.831.157 4.234 1.026 1.12 1.647 2.548 1.647 4.295 0 6.145-3.743 7.498-7.306 7.895.574.497 1.085 1.47 1.085 2.963 0 2.141-.019 3.864-.019 4.391 0 .426.288.925 1.099.768C27.421 29.457 32 23.462 32 16.395c0-8.837-7.164-16-16-16z"></path></svg>

            </a>
          </div>
          <div class="flex-grow text-right">
            @2021
          </div>
        </div>
      
    </footer>
  
    
  <script>
  document.addEventListener('DOMContentLoaded', () => {
    const disposable = document.querySelectorAll('[disposable]');
    Array.from(disposable).map(item => {item.remove()});
  });
</script>

<svg style="width:0;height:0;position:absolute;" aria-hidden="true" focusable="false">
  <linearGradient id="logoGradient" x2="1" y2="1">
    <stop offset="0%" stop-color="#cfb41a"></stop>
    <stop offset="50%" stop-color="#d86c14"></stop>
    <stop offset="100%" stop-color="#d81414"></stop>
  </linearGradient>
</svg>

</body></html>